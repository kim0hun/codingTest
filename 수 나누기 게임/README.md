## 1. 문제 정보

문제: 수 나누기 게임
링크: https://www.acmicpc.net/problem/27172

### 문제

《보드게임컵》을 준비하다 지친 은하는 보드게임컵 참가자들을 경기장에 몰아넣고 결투를 시키는 게임 《수 나누기 게임》을 만들었습니다.

《수 나누기 게임》의 규칙은 다음과 같습니다.

- 게임을 시작하기 전 각 플레이어는 $1$부터 $1,000,000$ 사이의 수가 적힌 서로 다른 카드를 잘 섞은 뒤 한 장씩 나눠 가집니다.
- 매 턴마다 플레이어는 다른 플레이어와 한 번씩 결투를 합니다.
- 결투는 서로의 카드를 보여주는 방식으로 진행되며, 플레이어의 카드에 적힌 수로 다른 플레이어의 카드에 적힌 수를 나눴을 때, 나머지가 $0$이면 승리합니다. 플레이어의 카드에 적힌 수가 다른 플레이어의 카드에 적힌 수로 나누어 떨어지면 패배합니다. 둘 다 아니라면 무승부입니다.
- 승리한 플레이어는 $1$점을 획득하고, 패배한 플레이어는 $1$점을 잃습니다. 무승부인 경우 점수의 변화가 없습니다.
- 본인을 제외한 다른 모든 플레이어와 정확히 한 번씩 결투를 하고 나면 게임이 종료됩니다.

《수 나누기 게임》의 결과를 가지고 한별이와 내기를 하던 은하는 게임이 종료되기 전에 모든 플레이어의 점수를 미리 알 수 있을지 궁금해졌습니다. 은하를 위해 각 플레이어가 가지고 있는 카드에 적힌 수가 주어졌을 때, 게임이 종료된 후의 모든 플레이어의 점수를 구해주세요.

### 제한사항

첫 번째 줄에 플레이어의 수 
$N$이 주어집니다.

두 번째 줄에 첫 번째 플레이어부터 
$N$번째 플레이어까지 각 플레이어가 가지고 있는 카드에 적힌 정수 
$x_{1}$, 
$\cdots$, 
$x_{N}$이 공백으로 구분되어 주어집니다.

## 2. 접근 방식

1. **입력 처리 및 초기화**
   - `n`: 플레이어의 수.
   - `player_card`: 각 플레이어가 가진 카드 번호.
   - `player_card_dict`: 카드 번호와 해당 플레이어의 인덱스를 딕셔너리 형태로 저장하여 빠른 검색을 가능하게 함.
   - `max_card`: 카드 중 가장 큰 값을 저장.
   - `result`: 각 플레이어의 최종 점수를 저장할 리스트. 초기 값은 모두 0으로 설정.

   ```python
   n = int(input())
   player_card = list(map(int, input().split()))
   player_card_dict = {card: idx for idx, card in enumerate(player_card)}
   max_card = max(player_card)
   result = [0] * n
   ```

2. **점수 계산 로직**
   - 각 플레이어가 가진 카드(`card`)를 기준으로:
     - `card`의 배수에 해당하는 카드가 `player_card`에 존재하면:
       - 해당 배수의 카드 소유자의 점수를 1 감소.
       - 현재 카드 소유자의 점수를 1 증가.
   - 내부적으로는 `range(card*2, max_card+1, card)`를 사용하여 배수를 효율적으로 탐색.

   ```python
   for i in range(n):
       card = player_card[i]
       for j in range(card*2, max_card+1, card):
           if j in player_card_dict.keys():
               idx = player_card_dict[j]
               result[i] += 1
               result[idx] -= 1
   ```

   - 예를 들어, 플레이어가 가진 카드가 3이라면, 3의 배수인 6, 9, 12... 등의 카드가 존재하는지 확인.
   - 존재한다면, 각 점수를 업데이트.

3. **결과 출력**
   - 최종 점수를 `result` 배열에서 순서대로 출력.

   ```python
   for i in result:
       print(i, end=' ')
   ```

## 3. 회고

### +Solution

### 유용한 라이브러리 or 메서드
