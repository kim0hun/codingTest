## 1. 문제 정보

**문제**: 이모티콘  
**링크**: [백준 14226번 - 이모티콘](https://www.acmicpc.net/problem/14226)

### 문제 설명  
- 화면에 이모티콘을 `S`개 만들기 위한 최소 시간(`t`)을 구하는 문제이다.  
- 사용할 수 있는 연산은 다음 세 가지이다.  
  1. 현재 화면의 이모티콘을 **클립보드에 복사** (Ctrl+C)
  2. 클립보드의 내용을 **화면에 붙여넣기** (Ctrl+V)
  3. 화면의 이모티콘 중 하나를 **삭제**  

### 입력  
- 정수 `S` (1 ≤ S ≤ 1000)  
- 화면에 `S`개의 이모티콘을 만들기 위해 필요한 최소 시간을 출력한다.  

### 출력  
- 이모티콘을 정확히 `S`개 만들기 위한 최소 연산 횟수를 출력한다.  

---

## 2. 접근 방식  

- **BFS(너비 우선 탐색)** 를 사용하여 최단 시간을 구한다.  
- 상태를 `(현재 화면의 이모티콘 개수, 클립보드의 이모티콘 개수, 현재 시간)`으로 정의한다.  
- 방문 여부를 `visited[이모티콘 개수][클립보드 개수]` 배열로 관리한다.  
- 가능한 연산 3가지를 활용하여 다음 상태를 탐색한다.  

  | 연산 | 설명 |
  |------|------|
  | 복사 | 현재 화면의 이모티콘을 클립보드에 복사 |
  | 붙여넣기 | 클립보드에 있는 이모티콘을 화면에 추가 |
  | 삭제 | 화면의 이모티콘을 하나 삭제 |

- BFS를 이용해 모든 경우를 탐색하며, `S`개가 되었을 때의 최소 시간을 구한다.  

---

## 3. 회고  

### ✅ 어려웠던 점  
- 상태를 `(현재 화면 이모티콘 개수, 클립보드 개수)`로 저장해야 한다는 점을 떠올리는 것이 어려웠다.  
- 방문 체크를 `visited[이모티콘 개수][클립보드 개수]`로 해야 하는 점을 간과했다.  

### ✅ 해결 방법  
- BFS를 사용하여 모든 경우를 탐색하고, 최단 경로를 찾도록 구현하였다.  
- `visited` 배열을 활용하여 중복 탐색을 방지하였다.  

### ✅ 개선할 점  
- `S`가 크더라도 더 빠르게 탐색할 수 있는 최적화 방법이 있는지 고민해 볼 필요가 있다.  
- DP(동적 계획법) 접근 방식과 비교해보는 것도 도움이 될 것 같다.  

---