## 1. 문제 정보

**문제**: 양팔저울
**링크**: [백준 2629번](https://www.acmicpc.net/problem/2629)

### 문제 설명
- 양팔 저울과 몇 개의 추가 주어졌을 때, 특정 무게의 구슬을 저울을 이용하여 측정할 수 있는지 판단하는 문제
- 추가 양팔 저울에 올려질 수 있으며, 한쪽에만 올려서 무게를 비교할 수도 있음
- 가능한 무게 조합을 계산하여 주어진 구슬의 무게를 측정할 수 있는지 확인

### 입력
1. `N` (추의 개수)
2. `N`개의 추 무게
3. `M` (구슬 개수)
4. `M`개의 구슬 무게

### 출력
- 각 구슬에 대해 측정 가능하면 `Y`, 불가능하면 `N`을 출력

---

## 2. 접근 방식

### 🔹 가능한 무게의 조합을 저장
- 특정 추를 사용할 때, 기존에 만들 수 있던 무게에서 새로운 무게를 만들 수 있는 경우를 고려
- 기존 값 그대로 유지, 새로운 추를 더한 값, 새로운 추를 뺀 값을 각각 추가하여 가능한 무게 확장

### 🔹 BFS (너비 우선 탐색) 활용
- `Deque<Integer>`를 사용하여 가능한 무게들을 탐색하며 추가적인 경우의 수를 확장
- 중복 제거를 위해 `LinkedHashSet`을 사용하여 `Deque`을 갱신
- 가능한 무게들을 `boolean[] weightCase` 배열에 저장하여 이후 입력받은 구슬의 무게가 가능한지 O(1)로 판별

### 🔹 BFS 구현 과정
1. `Deque`에 초기 상태 `0` 삽입
2. `Deque`에서 값을 하나씩 꺼내며 현재 추를 활용해 `현재 무게`, `더한 무게`, `뺀 무게`를 큐에 삽입
3. 중복된 무게를 제거하기 위해 `LinkedHashSet`을 활용하여 `Deque`을 갱신
4. 최종적으로 가능한 무게를 `weightCase` 배열에 저장
5. 입력받은 구슬 무게가 가능한지 `weightCase[ball]`를 통해 판단

---

## 3. 회고

### ✅ 어려웠던 점
- 가능한 무게의 중복을 제거하는 방식 고민
- 단순한 DFS가 아니라 BFS를 활용하여 모든 경우를 탐색해야 함

### ✅ 해결 방법
- BFS 탐색 중 중복된 값을 방지하기 위해 `LinkedHashSet`을 사용
- `weightCase` 배열을 활용하여 O(1)로 정답을 판별할 수 있도록 최적화

### ✅ 개선할 점
- `LinkedHashSet`을 사용했지만, 다른 방식(예: `boolean[]`을 활용한 즉시 중복 체크)으로 최적화할 방법도 고려 가능
- 더 큰 범위의 문제에서도 적용할 수 있도록 DP 방식과 비교해보는 것도 의미 있을 것

