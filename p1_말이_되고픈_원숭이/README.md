## 1. 문제 정보

**문제**: 말이 되고픈 원숭이  
**링크**: [백준 1600번](https://www.acmicpc.net/problem/1600)

### 문제 설명
- 원숭이는 체스판 위의 **말처럼 이동**할 수 있는 능력을 가질 수 있음
- 하지만 그 능력을 **최대 K번**만 사용할 수 있음
- 원숭이는 기본적으로 **상하좌우로 한 칸씩** 이동할 수 있음
- 장애물이 있는 곳은 갈 수 없음
- `(0,0) → (H-1, W-1)`로 이동하는 최소 이동 횟수를 구하는 문제

### 입력
1. `K` (말 이동 가능 횟수)
2. `W H` (가로, 세로 크기)
3. `H x W` 크기의 지도 (0: 이동 가능, 1: 장애물)

### 출력
- (H-1, W-1)까지 도달하는 최소 이동 횟수
- 도달할 수 없으면 `-1` 출력



## 2. 접근 방식

### 🔹 BFS (너비 우선 탐색) 활용
- 최소 이동 횟수를 구해야 하므로 **BFS**를 사용
- 방문 여부를 **3차원 배열** `visited[x][y][horseMovesLeft]`로 관리
  - `(x, y)` 좌표에서 `말 이동 횟수(horseMovesLeft)`가 `k`일 때 방문 여부 체크
- 이동 방식
  1. **원숭이 이동** → 상, 하, 좌, 우 (4방향 이동)
  2. **말 이동 (K번 사용 가능)** → 체스판 말의 이동 방식 (8방향 점프)
- `Queue<State>`를 활용하여 BFS 탐색 수행
- 목표 `(H-1, W-1)`에 도달하면 즉시 `level(이동 횟수)` 반환
- 모든 경우 탐색 후 도달할 수 없으면 `-1` 반환

### 🔹 BFS 구현 과정
1. `Queue`에 초기 상태 `(0, 0, 0, K)` 삽입 (시작점, 이동 횟수 0, 말 이동 가능 K번)
2. 큐에서 하나씩 꺼내며 원숭이 이동(4방향) 및 말 이동(8방향)을 수행
3. 방문한 좌표와 남은 말 이동 횟수를 기준으로 `visited` 배열 관리
4. 목표 좌표 `(H-1, W-1)`에 도달하면 즉시 최소 횟수 반환
5. 모든 경우 탐색 후 도달 불가능하면 `-1` 반환



## 3. 회고

### ✅ 어려웠던 점
- BFS를 3차원으로 구현하는 것이 익숙하지 않았음
- 방문 여부를 `visited[x][y][horseMovesLeft]`로 관리하는 점이 까다로웠음
- 단순 BFS와 다르게, **남은 말 이동 횟수에 따라 방문 처리를 다르게 해야 함**

### ✅ 해결 방법
- BFS를 진행할 때 **말 이동 가능 횟수를 상태값으로 추가**하여 관리
- `visited` 배열을 3차원으로 만들어 말 이동 횟수별로 관리
- **단순 BFS와 말 이동 BFS를 하나의 큐에서 관리**하도록 구현

### ✅ 개선할 점
- BFS를 활용한 문제에서 상태 관리하는 방법을 더 연습할 필요가 있음
- 말 이동 횟수가 `K`에서 점점 감소하므로, 이를 활용한 최적화 고민 필요

