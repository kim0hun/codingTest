## 1. 문제 정보
문제: 보물섬
링크: https://www.acmicpc.net/problem/2589

### 문제
보물섬 지도를 발견한 후크 선장은 보물을 찾아나섰다. 보물섬 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 각 칸은 육지(L)나 바다(W)로 표시되어 있다. 이 지도에서 이동은 상하좌우로 이웃한 육지로만 가능하며, 한 칸 이동하는데 한 시간이 걸린다. 보물은 서로 간에 최단 거리로 이동하는데 있어 가장 긴 시간이 걸리는 육지 두 곳에 나뉘어 묻혀있다. 육지를 나타내는 두 곳 사이를 최단 거리로 이동하려면 같은 곳을 두 번 이상 지나가거나, 멀리 돌아가서는 안 된다.

예를 들어 위와 같이 지도가 주어졌다면 보물은 아래 표시된 두 곳에 묻혀 있게 되고, 이 둘 사이의 최단 거리로 이동하는 시간은 8시간이 된다.

보물 지도가 주어질 때, 보물이 묻혀 있는 두 곳 간의 최단 거리로 이동하는 시간을 구하는 프로그램을 작성하시오.

## 2. 접근 방식

1. 큐 초기화:
- deque를 사용해 BFS 탐색 상태를 관리합니다.
- 큐에 (x, y, level) 형태로 시작 좌표와 초기 거리를 추가합니다.
2. 방문 처리:
- 방문 여부를 기록하기 위해 visited 배열(2차원)을 사용합니다.
- 현재 위치를 방문 처리(visited[x][y] = 1)합니다.
3. 탐색 로직:
- 큐에서 현재 좌표를 꺼내, 네 방향(상, 하, 좌, 우)으로 이동 가능한지 확인합니다.
- 이동 가능한 칸은:
  - 지도 내 범위(0 <= nextx < h 및 0 <= nexty < w)에 속하고,
  - 육지 칸(island[nextx][nexty] == 'L'),
  - 방문하지 않은 칸(visited[nextx][nexty] == 0)입니다.
- 조건을 만족하면 큐에 추가하고 방문 처리합니다.
4. 최대 거리 반환:
- BFS가 종료되면, 가장 마지막에 탐색된 거리(level)을 반환합니다.

## 3. 회고

반복문 안에 bfs를 직접 구현하는것보다 함수로 따로 빼서 구현하는 것이 속도 측면에서 더 빠르다.
bfs 함수로 따로 빼지 않을 경우 무조건 `시간 초과`가 발생.

### +Solution

### 유용한 라이브러리 or 메서드
