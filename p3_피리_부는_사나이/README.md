## 1. 문제 정보

**문제**: 피리 부는 사나이  
**링크**: [백준 16724번](https://www.acmicpc.net/problem/16724)

### 문제 설명
- `N × M` 크기의 지도에서 각 칸에 `U`, `D`, `L`, `R`로 표시된 방향이 주어짐  
- 각 칸은 해당 방향으로 이동할 수 있음  
- 이동을 반복하면서 **사이클이 형성되는 구역**을 찾는 문제  
- 서로 연결된 칸들을 하나의 **안전 구역**으로 간주하여, **안전 구역의 수**를 구하는 문제  

### 입력
1. `N`과 `M`이 주어짐 (세로와 가로 크기)  
2. `N`개의 줄에 `M`개의 문자로 이루어진 지도 (`U`, `D`, `L`, `R`)  

### 출력
- 총 몇 개의 **안전 구역**이 존재하는지 출력  

---

## 2. 접근 방식

### 🔹 그래프 탐색 (DFS)
- 각 칸은 **방향이 정해진 그래프의 노드**와 같음  
- 방향에 따라 인접한 칸으로 이동하면서 **방문하지 않은 칸들을 탐색**  
- 사이클을 형성하는 칸들이 존재한다면 그 칸들로 하나의 **안전 구역**을 형성  
- DFS를 사용하여 방문을 마친 칸에 대해 **사이클이 형성되었는지 확인**하고, **새로운 안전 구역**을 카운트

### 🔹 DFS 구현
- `visited[][]` 배열을 활용하여 각 칸의 상태를 관리:
  - `0`: 미방문
  - `1`: 탐색 중
  - `2`: 탐색 완료
- 방문 중인 칸을 다시 방문하면 **사이클이 형성된 것**으로 판단하고 안전 구역을 증가시킴  
- **방향을 지정한 `dirMap`**을 사용하여 각 칸에서 이동할 방향을 효율적으로 찾음  

### 🔹 DFS 탐색 과정
1. **각 칸에 대해 DFS 시작**  
2. **방향에 따라 다음 칸으로 이동**  
3. **다음 칸을 탐색하기 전에 방문 여부 확인**  
   - `1`: 사이클이 발생한 구역
   - `0`: 방문하지 않은 구역
   - `2`: 탐색이 완료된 구역  
4. **사이클이 발생한 구역은 새로운 안전 구역으로 카운트**

---

## 3. 회고

### ✅ 어려웠던 점
- **사이클을 판별하는 로직**이 처음에 헷갈렸음  
  - `visited` 배열을 잘 활용하고, 사이클을 발생시킬 때만 안전 구역을 카운트하는 로직을 신경 써야 했음

### ✅ 해결 방법
- **`visited` 배열**을 이용하여 탐색 중인 칸을 구분하고, 사이클이 발생했을 때만 카운트를 증가시킴  
- 각 칸에 대해 **방향을 확인하여** 이동할 수 있는 곳으로 정확히 이동하며 탐색을 진행

### ✅ 개선할 점
- **코드 최적화** 면에서는 문제 없이 효율적으로 동작하지만, DFS 외에도 **BFS 또는 유니온 파인드**를 활용한 풀이를 고려할 수도 있음
- **재귀 깊이**에 의한 스택 오버플로우 문제를 방지하기 위해 **반복문 DFS**나 **BFS**를 사용해볼 수도 있음
