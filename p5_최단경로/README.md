### **1. 문제 정보**  

**문제**: 최단경로  
**링크**: [백준 1753번 - 최단경로](https://www.acmicpc.net/problem/1753)  

### **문제 설명**  
- 방향 그래프가 주어지고, 시작 정점에서 다른 모든 정점까지의 최단 경로를 구하는 문제이다.  
- 간선에는 가중치가 있으며, 최단 경로를 출력해야 한다.  
- 도달할 수 없는 정점은 `"INF"`로 출력한다.  

### **입력**  
1. 정점의 개수 `V`, 간선의 개수 `E`  
2. 시작 정점 `K`  
3. `E`개의 줄에 걸쳐 `u, v, w` (정점 `u`에서 정점 `v`로 가는 가중치 `w`인 간선)  

### **출력**  
- 시작 정점 `K`에서 각 정점까지의 최단 거리 출력  
- 도달할 수 없는 경우 `"INF"` 출력  

---

### **2. 접근 방식**  
- **다익스트라 알고리즘**을 사용하여 최단 경로를 계산  
- **우선순위 큐(PriorityQueue)** 를 활용하여 효율적인 최단 거리 탐색 수행  
- **거리 배열(`distance[]`)** 을 사용하여 각 정점까지의 최단 거리 저장  
- **인접 리스트(List of Lists)** 로 그래프를 표현하여 메모리 효율성을 높임  

1. **그래프 저장**  
   - 인접 리스트를 사용하여 그래프 정보를 저장  
2. **다익스트라 알고리즘 수행**  
   - `PriorityQueue<Node>`를 사용하여 최단 거리 갱신  
   - `distance[]` 배열을 활용하여 최단 거리 정보 저장  
3. **출력 처리**  
   - `distance[]` 값을 확인하여 정점별 최단 거리 출력  
   - 도달할 수 없는 경우 `"INF"` 출력  

---

### **3. 회고**  

#### ✅ **어려웠던 점**  
- `PriorityQueue` 내부의 동작을 이해하고, 현재 노드와 거리 갱신 로직을 적용하는 과정이 헷갈렸다.  

#### ✅ **해결 방법**  
- `PriorityQueue` 내부 상태를 `toArray()`로 출력하여 정렬된 상태를 확인하면서 디버깅을 진행하였다.  
- `if (distance[currentIndex] < currentDistance) continue;` 조건을 활용하여 **불필요한 연산을 줄이는 방법**을 익혔다.  

#### ✅ **개선할 점**  
- 다른 최단 경로 알고리즘(벨만-포드, 플로이드-워셜)과 비교하여 성능 차이를 분석해볼 필요가 있다.  
- 배열 기반 우선순위 큐(예: `PriorityQueue` 대신 `TreeSet` 활용) 등의 다른 구현 방식도 실험해볼 가치가 있다.  